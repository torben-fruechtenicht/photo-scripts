#! /usr/bin/env bash

set -eu

source "$(dirname "$(readlink -e "$0")")/lib/exif.sh"

declare -r CREATE_SIDECAR_CMD="$(dirname "$(readlink -e "$0")")/profile-builder/create_sidecar"
declare -r TMP_DIR=$(mktemp -d)

cleanup() {
  test -e "$TMP_DIR" && rm -rf "$TMP_DIR"
}
trap cleanup EXIT


while getopts "c:k:t:g" opt; do
    case $opt in
        c ) 
			declare -r CREATOR_OPTION=$OPTARG;;   
		k ) 
			# CSV string, using ";". no quoting needed for keywords with blanks
			declare -r KEYWORDS_OPTION=$OPTARG;;		
        t )
            declare -r SIDECAR_TEMPLATES_DIR=$(readlink -e "$OPTARG");;
        g )
            declare -r USE_GUI=;;    
	esac
done
shift $(expr $OPTIND - 1 )

if ! [[ -v SIDECAR_TEMPLATES_DIR ]]; then
    echo "No sidecar templates dir given or does not exist" >&2
    exit 1
fi
declare -r DCIM_DIR=$(readlink -e "$1")
if [[ -z $DCIM_DIR ]]; then
    echo "[ERROR] No DCIM directory given or does not exist" >&2
    exit 1
fi
declare -r TARGET_DIR=$(readlink -e "$2")
if [[ -z $TARGET_DIR ]]; then
    echo "[ERROR] No target directory given or does not exist" >&2
    exit 1
fi

run_options_dialog() {
  
    yad \
		--title="Import photos from DCIM directory $DCIM_DIR" \
		--form \
		--field="Album:TEXT" "New photos" \
        --field="Photo title:TEXT" "" \
        --field="Photographer/creator:TEXT" "${CREATOR_OPTION+$CREATOR_OPTION}" \
		--field="Keywords (separated by \";\"):TEXT" "${KEYWORDS_OPTION+$KEYWORD_OPTIONS}" \
        --field="Only from date:DT" 2> /dev/null
    
    if [[ $? = 252 ]]; then
        echo "[INFO] Cancelled" >&2
        exit
    fi
}

if [[ -v USE_GUI ]]; then

    options_string="$(run_options_dialog)"

    declare -r ALBUM="$(echo "$options_string" | cut -d'|' -f 1 | tr ' ' '-')"

    title_string="$(echo "$options_string" | cut -d'|' -f 2 | tr ' ' '-')"
    if [[ -n $title_string ]]; then
        declare -r TITLE="$title_string"
    else 
        declare -r TITLE=$ALBUM
    fi
    
    declare -r CREATOR="$(echo "$options_string" | cut -d'|' -f 3)"

    keywords_string="$(echo "$options_string" | cut -d'|' -f 4)"
    test -n "$keywords_string" && declare -r KEYWORDS=$keywords_string

    declare -r DATE_TAKEN="$(echo "$options_string" | cut -d'|' -f 5)"

else 
    
    declare -r ALBUM="$(echo "${3+$3}" | tr ' ' '-')"
    if [[ -z $ALBUM ]]; then
        echo "[ERROR] No album name given" >&2
        exit 1
    fi

    declare -r TITLE=$ALBUM
    test -v CREATOR_OPTION && declare -r CREATOR=$CREATOR_OPTION
    test -v KEYWORDS_OPTION && declare -r KEYWORDS=$KEYWORDS_OPTION
fi


build_photonumber_filename_with_leading_p() {
    local -r file_basename=$(basename "$1")
    # remove the leading "P"
    local -r p_removed=${file_basename:1}
    echo ${p_removed%%.*}
}

build_photonumber_canon_exif_filenumber() {
    # e.g. "100-2071"
     exiv2 -Pt -g 'Exif.Canon.FileNumber' "$1" 2> /dev/null | tr --delete '-' 
}

build_photonumber_olympus_filename() {
    # format of photo number: <MONTH><DAY><NUMBER>, zero-digit values of month or day
    # are *not zero-padded* but with leading underscore
    basename "$1" | tr '_' '0'
}

camera_id() {
    local -r photofile=$1
    local -r manufacturer=$(lookup_manufacturer_from_exif "$photofile")
    local -r camera=$(lookup_camera_from_exif "$photofile")

    echo "$manufacturer $camera" | tr ' ' '_'
}

build_photonumber() {
    local -r photofile=$1
    case "$(camera_id "$photofile")" in 
        Panasonic_DMC-FZ50 )
            build_photonumber_filename_with_leading_p "$photofile";;
        Canon_CanonPowerShotG9|Canon_CanonPowerShotS70 )
            build_photonumber_canon_exif_filenumber "$photofile";;
        OLYMPUS_IMAGING_CORP._E-M10 )
            build_photonumber_olympus_filename "$photofile";;
    esac
}

camera_name() { 
    local -r photofile=$1
    case "$(camera_id "$photofile")" in 
        Panasonic_DMC )
            echo "fz50";;
        Canon_CanonPowerShotG9 )
            echo "g9";;
        Canon_CanonPowerShotS70 )
            echo "s70";;
        OLYMPUS_IMAGING_CORP._E-M10 )
            echo "e-m10";;
    esac
}

build_targetpath() {
    local -r photofile=$1

    local -r datetimeoriginal=$(exiv2 -Pt -g 'Exif.Photo.DateTimeOriginal' "$photofile" 2> /dev/null)
	
    local -r year=$(echo "$datetimeoriginal" | cut -d':' -f 1)
	local -r date=$(echo "$datetimeoriginal" | cut -d' ' -f 1 | tr ':' '-')
    local -r date_numerical=$(echo "$datetimeoriginal" | cut -d' ' -f 1 | tr --delete ':')
	local -r timeofday=$(echo "$datetimeoriginal" | cut -d' ' -f2 | cut -d ':' -f1-2 | tr --delete ':')

    local -r target_dir="$TARGET_DIR/$year/$ALBUM/$date"

    echo "${target_dir}/${TITLE}_${date_numerical}_${timeofday}_$(camera_name "$photofile")_$(build_photonumber "$photofile")"
}

declare -r EXTENSIONS=".+\.(ORF|CRW|CR2|RAW|JPG)"
# TODO to use DATE, add another step to pipeline: get date from photofile and compare with DATE, print photofile to stdout
# if dates match.
# Using find checks will not work, they only check if newer as a given date
# DOC when using find with both -exec (for copying) and -printf (for the filename), copying must happen first. Otherwise
# the name will already have been printed to stdout before the file was copied
find "$DCIM_DIR" -regextype posix-extended -type f -iregex $EXTENSIONS \
    -exec cp --preserve=timestamps {} "$TMP_DIR" \; -printf "$TMP_DIR"'/%f\n' | while read -r photofile; do

    target_filename=$(build_targetpath "$photofile")

    if [[ -e $target_filename ]]; then
        echo "[WARN] $target_filename exists, skipping" >&2
        continue
    fi
    
    if [[ -z $(readlink -f "$target_filename") ]]; then
        mkdir --parents "$(dirname "$target_filename")"
    fi

    cp --preserve=timestamps "$photofile" "$target_filename"
    chmod -w "$target_filename"

    echo "$target_filename"

done | xargs --no-run-if-empty "$CREATE_SIDECAR_CMD" ${CREATOR+-c "$CREATOR"} ${KEYWORDS+-k "$KEYWORDS"} "$SIDECAR_TEMPLATES_DIR" |\
# the output of actual copying of the photos (i.e. the target filenames of the photos) is swallowed by create_sidecar
# therefore, print all filenames (photos and sidecars) in a final step
while read -r sidecar_file; do
    echo "${sidecar_file%.*}"
    echo "$sidecar_file"
done