#! /usr/bin/env bash

set -ue

declare -r BASE_DIR="$(dirname "$(readlink -e "$0")")/../.."

source "$BASE_DIR/lib/strings.sh"
source "$BASE_DIR/lib/photofiles.sh"
source "$BASE_DIR/lib/jpeg_iptc.sh"
source "$BASE_DIR/lib/iptc.sh"


function write_jpeg_iptc() (
    set +e

    local -r file=$1

    if [[ -v CREATOR ]]; then
        jpeg_set_iptc "$file" "Byline" "$CREATOR" 
        if [[ $? != 0 ]]; then
            echo "[ERROR] Failed writing IPTC byline of $file" >&2
        fi

        local -r year_from_exif=$(exiv2 -Pt -g 'Exif.Photo.DateTimeOriginal' "$file" 2> /dev/null | cut -d':' -f 1)
        jpeg_set_iptc "$file" "Copyright" "Copyright (c) $CREATOR $year_from_exif"
        if [[ $? != 0 ]]; then
            echo "[ERROR] Failed writing IPTC copyright of $file" >&2
        fi
    fi

    jpeg_set_iptc "$file" "Headline" "$(iptc_headline_from_photofile "$file" )"
    if [[ $? != 0 ]]; then
        echo "[ERROR] Failed writing IPTC headline of $file" >&2
    fi
	jpeg_set_iptc "$file" "Caption" "$(iptc_caption_from "$(photoid "$file")" "")"
    if [[ $? != 0 ]]; then
        echo "[ERROR] Failed writing IPTC caption of $file" >&2
    fi

    jpeg_set_iptc_keywords "$file" "$KEYWORDS"
    if [[ $? != 0 ]]; then
        echo "[ERROR] Failed writing IPTC keywords of $file" >&2
    fi
)

# there is no way to do "test -e $glob" (where $glob expands to more than one file) 
# in the bash shell, unfortunately.
# the secure way out of this dilemma is to use compgen
# see https://stackoverflow.com/a/34195247/1295519
function glob_matches() {
    local -r glob=$1
    compgen -G "$glob" > /dev/null
}


while getopts "c:k:" opt; do
    case $opt in
        c ) 
			declare -r CREATOR=$OPTARG
            ;;   
		k ) 
			# CSV string, using ";". no quoting needed for keywords with blanks
			declare -r KEYWORDS=$OPTARG
            ;;
	esac
done


while read -r file; do

    if [[ $file =~ .+/converted/.+\.jpg ]]; then
        write_jpeg_iptc "$file"

        # if any of the operations in write_jpeg_iptc fails, exiv2 will leave
        # its tmp files around. Delete any which match the pattern for these
        # tmp files.
        if glob_matches "$file?*"; then
            rm $file?*
        fi
    fi

    echo "$file"
    
done < /dev/stdin