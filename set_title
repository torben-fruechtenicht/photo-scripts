#! /usr/bin/env bash

set -eu
shopt -s nocasematch

declare -r BASE_DIR="$(dirname "$(readlink -e "$0")")"
source "$BASE_DIR/lib/metadata.sh"
source "$BASE_DIR/lib/sidecar.sh"
source "$BASE_DIR/lib/jpeg.sh"


declare -r TITLE=${1:-}
if [[ -z $TITLE ]]; then
    echo "[ERROR] Title parameter missing" >&2
    exit 1
elif [[ -f $TITLE || -d $TITLE ]]; then
	echo "[ERROR] Title parameter is a file or directory" >&2
	exit 1
fi

shift 1

if [[ ${1:-} = "-" ]]; then
    declare -r READ_FILES_FROM_STDIN=
else 
    declare -r FILES=$@
fi


new_filename() {
    local -r filename=$1
    local -r newtitle=$2

    echo "${newtitle}_${filename#*_}"
}

old_title() {
    local file=$1
    local basename=$(basename "$1")
    echo ${basename%%_*}
}

apply_set_title() {

    local -r file=$1
    local -r filename=${file##*/}

    if [[ $(old_title "$file") = $TITLE ]]; then
        echo "[WARN] Cannot change title of $file to \"$TITLE\", same as old title" >&2
        return
    fi

    if ! [[ -w $file ]]; then
        chmod u+w "$file"
        local -r restore_write_protection=
    fi

    local -r newfile="$(dirname "$file")/$(new_filename "$filename" "$TITLE")"

    # this is a real error case unlike the other check above (which stems from careless user input)
    if [[ -e $newfile ]]; then
        echo "[ERROR] Cannot change title of $file to \"$TITLE\", file $newfile exists already" >&2
        exit 1
    fi

    if [[ $file = *.pp[23] ]] || [[ $file = */converted/*.jpg ]]; then
        
        local -r iptc_headline=$(headline_from_photofile "$newfile")
        local -r iptc_caption="[$(fullname_from_photofile "$newfile")]"   
        if [[ $file = *.pp[23] ]]; then
            sidecar_set_property "$file" "IPTC" "Headline" "$iptc_headline"
            sidecar_set_property "$file" "IPTC" "Caption" "$iptc_caption"    
        elif [[ $file = */converted/*.jpg ]]; then
            jpeg_set_iptc "$file" "Headline" "$iptc_headline"
            jpeg_set_iptc "$file" "Caption" "$iptc_caption"
        fi
    fi

    mv -u "$file" "$newfile"
    
    if [[ -v restore_write_protection ]]; then
        chmod u-w "$newfile"
    fi

    echo "$newfile"
}


if [[ -v READ_FILES_FROM_STDIN ]]; then
    while read -r file; do 
        apply_set_title "$file"
    done < /dev/stdin
else 
    for file in $FILES; do 
        apply_set_title "$file"
    done
fi